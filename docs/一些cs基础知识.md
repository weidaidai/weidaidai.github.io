### git

合并分支到主分支master

创建commit新分支内容后并提交分支到GitHub后，切换到主分支

git checkout master
然后从GitHub拉回主分支master(自己开发可以不用，保险还是要）

git pull origin master
合并新分支到master ，然后提交master

git merge chgl16
git status  # 仅查看状态
git push origin master

### 栈（Stack）与堆（Heap）

栈和堆是编程语言最核心的数据结构，但是在很多语言中，你并不需要深入了解栈与堆。 但对于Rust这样的系统编程语言，值是位于栈上还是堆上非常重要, 因为这会影响程序的行为和性能。

栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间，关于它们的详细解释和实现方式，请参见[Rust代码鉴赏](https://codes.rs/data-structures/heap.html)一书.

#### 栈

栈按照顺序存储值并以相反顺序取出值，这也被称作 **后进先出**。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！

增加数据叫做 **进栈**，移出数据则叫做 **出栈**。

因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。

#### 堆

与栈不同，对于大小位置或者可能变化的数据，我们需要将它存储在堆上。

当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 **指针**, 该过程被称为 **在堆上分配内存**，有时简称为 “分配”（allocating）。

接着，该指针会被推入`栈`中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。

由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭: 进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子(堆上分配的内存空间)并领你们过去。如果有人来迟了，他们也可以通过桌号(栈上的指针)来找到你们坐在哪。

#### 性能区别

入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间：新数据的位置放入栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。

访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问内存。得益于CPU高速缓存，现代处理器访问内存的次数越少则越快，栈数据往往可以存储在cpu高速缓存中，而堆数据只能存储在内存中，这两者的访问速度差异在10倍以上！

因此，处理器在处理栈上数据的时候比处理堆上的数据更加高效，同时，在堆上分配大量的空间也可能消耗时间。